<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Programming Patterns Cheatsheet</title>
    <link rel="stylesheet" href="../styles.css">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="../script.js" defer></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-content">
            <a href="../index.html" class="nav-brand">
                <i class="ph ph-books"></i> Cheatsheets
            </a>
            <div class="nav-controls">
                <button id="theme-toggle" class="btn-icon" aria-label="Toggle theme">
                    <i class="ph ph-moon"></i>
                </button>
                <button id="download-btn" class="btn-icon" aria-label="Download PDF">
                    <i class="ph ph-download-simple"></i>
                </button>
                <a href="https://github.com/keyurgolani/Cheatsheets" class="btn-icon" aria-label="GitHub" target="_blank" rel="noopener noreferrer">
                    <i class="ph ph-github-logo"></i>
                </a>
            </div>
        </div>
    </nav>

    <div class="container">
        <header class="cheatsheet-header">
            <h1>üí∞ Dynamic Programming Patterns</h1>
            <p>Master the art of solving optimization problems through memoization and tabulation</p>
            <div class="search-container" style="margin-top: 1.5rem; margin-bottom: 0;">
                <span class="search-icon"><i class="ph ph-magnifying-glass"></i></span>
                <input type="text" class="search-input" id="cheatsheet-search" placeholder="Filter this cheatsheet..." aria-label="Filter cheatsheet">
            </div>
        </header>

        <div class="masonry-grid" id="cheatsheet-grid">
            
            <div class="card" id="what-is-dynamic-programming">
                <div class="card-header">üéØ What is Dynamic Programming?</div>
                <div class="code-block">
                    
                </div>
            </div>
            <div class="card" id="memoization-top-down">
                <div class="card-header">üìù Memoization (Top-Down)</div>
                <div class="code-block">
                    <div class="code-line"><span class="comment">// Fibonacci with memoization</span></div><div class="code-line"><span class="keyword">function</span> fib(n, memo = {}):</div><div class="code-line"> <span class="comment">// Base cases</span></div><div class="code-line"> <span class="keyword">if</span> n &lt;= 1:</div><div class="code-line"> <span class="keyword">return</span> n</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Check if already computed</span></div><div class="code-line"> <span class="keyword">if</span> n <span class="keyword">in</span> memo:</div><div class="code-line"> <span class="keyword">return</span> memo[n]</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Compute and store</span></div><div class="code-line">    memo[n] = fib(n - 1, memo) + fib(n - 2, memo)</div><div class="code-line"> <span class="keyword">return</span> memo[n]</div>
                </div>
            </div>
            <div class="card" id="tabulation-bottom-up">
                <div class="card-header">üìä Tabulation (Bottom-Up)</div>
                <div class="code-block">
                    <div class="code-line"><span class="comment">// Fibonacci with tabulation</span></div><div class="code-line"><span class="keyword">function</span> fib(n):</div><div class="code-line"> <span class="keyword">if</span> n &lt;= 1:</div><div class="code-line"> <span class="keyword">return</span> n</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Create table</span></div><div class="code-line">    dp = <span class="keyword">array</span>[n + 1]</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Base cases</span></div><div class="code-line">    dp[0] = 0</div><div class="code-line">    dp[1] = 1</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Fill table bottom-up</span></div><div class="code-line"> <span class="keyword">for</span> i = 2 <span class="keyword">to</span> n:</div><div class="code-line">        dp[i] = dp[i - 1] + dp[i - 2]</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> dp[n]</div>
                </div>
            </div>
            <div class="card" id="01-knapsack-pattern">
                <div class="card-header">üéí 0/1 Knapsack Pattern</div>
                <div class="code-block">
                    <div class="code-line"><span class="comment">// Problem: Max value with weight limit</span></div><div class="code-line"><span class="keyword">function</span> knapsack(weights, values, capacity):</div><div class="code-line">    n = length(weights)</div><div class="code-line">    dp = <span class="keyword">array</span>[n + 1][capacity + 1]</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Base case: 0 items or 0 capacity = 0 value</span></div><div class="code-line"> <span class="keyword">for</span> i = 0 <span class="keyword">to</span> n:</div><div class="code-line">        dp[i][0] = 0</div><div class="code-line"> <span class="keyword">for</span> w = 0 <span class="keyword">to</span> capacity:</div><div class="code-line">        dp[0][w] = 0</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Fill table</span></div><div class="code-line"> <span class="keyword">for</span> i = 1 <span class="keyword">to</span> n:</div><div class="code-line"> <span class="keyword">for</span> w = 1 <span class="keyword">to</span> capacity:</div><div class="code-line"> <span class="keyword">if</span> weights[i - 1] &lt;= w:</div><div class="code-line"> <span class="comment">// Max of: include item or exclude item</span></div><div class="code-line">                include = values[i - 1] + dp[i - 1][w - weights[i - 1]]</div><div class="code-line">                exclude = dp[i - 1][w]</div><div class="code-line">                dp[i][w] = max(include, exclude)</div><div class="code-line"> <span class="keyword">else</span>:</div><div class="code-line"> <span class="comment">// Can't include, too heavy</span></div><div class="code-line">                dp[i][w] = dp[i - 1][w]</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> dp[n][capacity]</div>
                </div>
            </div>
            <div class="card" id="longest-common-subsequence-lcs">
                <div class="card-header">üß¨ Longest Common Subsequence (LCS)</div>
                <div class="code-block">
                    <div class="code-line"><span class="comment">// Find longest common subsequence</span></div><div class="code-line"><span class="keyword">function</span> lcs(text1, text2):</div><div class="code-line">    m = length(text1)</div><div class="code-line">    n = length(text2)</div><div class="code-line">    dp = <span class="keyword">array</span>[m + 1][n + 1]</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Base case: empty string has LCS of 0</span></div><div class="code-line"> <span class="keyword">for</span> i = 0 <span class="keyword">to</span> m:</div><div class="code-line">        dp[i][0] = 0</div><div class="code-line"> <span class="keyword">for</span> j = 0 <span class="keyword">to</span> n:</div><div class="code-line">        dp[0][j] = 0</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Fill table</span></div><div class="code-line"> <span class="keyword">for</span> i = 1 <span class="keyword">to</span> m:</div><div class="code-line"> <span class="keyword">for</span> j = 1 <span class="keyword">to</span> n:</div><div class="code-line"> <span class="keyword">if</span> text1[i - 1] == text2[j - 1]:</div><div class="code-line"> <span class="comment">// Characters match, extend LCS</span></div><div class="code-line">                dp[i][j] = 1 + dp[i - 1][j - 1]</div><div class="code-line"> <span class="keyword">else</span>:</div><div class="code-line"> <span class="comment">// Take max from excluding one char</span></div><div class="code-line">                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> dp[m][n]</div>
                </div>
            </div>
            <div class="card" id="longest-increasing-subsequence-lis">
                <div class="card-header">üìà Longest Increasing Subsequence (LIS)</div>
                <div class="code-block">
                    <div class="code-line"><span class="comment">// DP approach O(n¬≤)</span></div><div class="code-line"><span class="keyword">function</span> lengthOfLIS(nums):</div><div class="code-line">    n = length(nums)</div><div class="code-line"> <span class="keyword">if</span> n == 0:</div><div class="code-line"> <span class="keyword">return</span> 0</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// dp[i] = length of LIS ending at index i</span></div><div class="code-line">    dp = <span class="keyword">array</span>[n] filled with 1</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for</span> i = 1 <span class="keyword">to</span> n - 1:</div><div class="code-line"> <span class="keyword">for</span> j = 0 <span class="keyword">to</span> i - 1:</div><div class="code-line"> <span class="keyword">if</span> nums[j] &lt; nums[i]:</div><div class="code-line"> <span class="comment">// Can extend LIS ending at j</span></div><div class="code-line">                dp[i] = max(dp[i], dp[j] + 1)</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> max(dp)</div><div class="code-line"></div><div class="code-line"><span class="comment">// Binary search approach O(n log n)</span></div><div class="code-line"><span class="keyword">function</span> lengthOfLIS_Optimized(nums):</div><div class="code-line">    tails = []  <span class="comment">// tails[i] = smallest tail of LIS of length i+1</span></div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for</span> num <span class="keyword">in</span> nums:</div><div class="code-line"> <span class="comment">// Binary search for position</span></div><div class="code-line">        pos = binarySearch(tails, num)</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">if</span> pos == length(tails):</div><div class="code-line">            tails.append(num)</div><div class="code-line"> <span class="keyword">else</span>:</div><div class="code-line">            tails[pos] = num</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> length(tails)</div>
                </div>
            </div>
            <div class="card" id="unbounded-knapsack">
                <div class="card-header">ü™ô Unbounded Knapsack</div>
                <div class="code-block">
                    <div class="code-line"><span class="comment">// Coin change: min coins to make amount</span></div><div class="code-line"><span class="keyword">function</span> coinChange(coins, amount):</div><div class="code-line">    dp = <span class="keyword">array</span>[amount + 1] filled with infinity</div><div class="code-line">    dp[0] = 0  <span class="comment">// Base case: 0 coins for amount 0</span></div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for</span> a = 1 <span class="keyword">to</span> amount:</div><div class="code-line"> <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</div><div class="code-line"> <span class="keyword">if</span> a - coin &gt;= 0:</div><div class="code-line"> <span class="comment">// Can use this coin</span></div><div class="code-line">                dp[a] = min(dp[a], 1 + dp[a - coin])</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != infinity <span class="keyword">else</span> -1</div><div class="code-line"></div><div class="code-line"><span class="comment">// Coin change: count ways to make amount</span></div><div class="code-line"><span class="keyword">function</span> coinChangeWays(coins, amount):</div><div class="code-line">    dp = <span class="keyword">array</span>[amount + 1] filled with 0</div><div class="code-line">    dp[0] = 1  <span class="comment">// One way to make 0: use no coins</span></div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Iterate coins first to avoid duplicates</span></div><div class="code-line"> <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</div><div class="code-line"> <span class="keyword">for</span> a = coin <span class="keyword">to</span> amount:</div><div class="code-line">            dp[a] += dp[a - coin]</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> dp[amount]</div>
                </div>
            </div>
            <div class="card" id="palindrome-patterns">
                <div class="card-header">üé≠ Palindrome Patterns</div>
                <div class="code-block">
                    <div class="code-line"><span class="comment">// Longest palindromic subsequence</span></div><div class="code-line"><span class="keyword">function</span> longestPalindromeSubseq(s):</div><div class="code-line">    n = length(s)</div><div class="code-line">    dp = <span class="keyword">array</span>[n][n]</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Base case: single character is palindrome</span></div><div class="code-line"> <span class="keyword">for</span> i = 0 <span class="keyword">to</span> n - 1:</div><div class="code-line">        dp[i][i] = 1</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Fill table for increasing lengths</span></div><div class="code-line"> <span class="keyword">for</span> length = 2 <span class="keyword">to</span> n:</div><div class="code-line"> <span class="keyword">for</span> i = 0 <span class="keyword">to</span> n - length:</div><div class="code-line">            j = i + length - 1</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">if</span> s[i] == s[j]:</div><div class="code-line"> <span class="comment">// Characters match, add 2</span></div><div class="code-line">                dp[i][j] = 2 + dp[i + 1][j - 1]</div><div class="code-line"> <span class="keyword">else</span>:</div><div class="code-line"> <span class="comment">// Take max excluding one end</span></div><div class="code-line">                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> dp[0][n - 1]</div><div class="code-line"></div><div class="code-line"><span class="comment">// Longest palindromic substring (expand around center)</span></div><div class="code-line"><span class="keyword">function</span> longestPalindrome(s):</div><div class="code-line"> <span class="keyword">if</span> length(s) &lt; 2:</div><div class="code-line"> <span class="keyword">return</span> s</div><div class="code-line"> </div><div class="code-line">    start = 0, maxLen = 0</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for</span> i = 0 <span class="keyword">to</span> length(s) - 1:</div><div class="code-line"> <span class="comment">// Odd length palindrome</span></div><div class="code-line">        len1 = expandAroundCenter(s, i, i)</div><div class="code-line"> <span class="comment">// Even length palindrome</span></div><div class="code-line">        len2 = expandAroundCenter(s, i, i + 1)</div><div class="code-line"> </div><div class="code-line">        len = max(len1, len2)</div><div class="code-line"> <span class="keyword">if</span> len &gt; maxLen:</div><div class="code-line">            start = i - (len - 1) / 2</div><div class="code-line">            maxLen = len</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> s[start:start + maxLen]</div>
                </div>
            </div>
            <div class="card" id="state-transition">
                <div class="card-header">üî¢ State Transition</div>
                <div class="code-block">
                    <div class="code-line"><span class="comment">// Best time to buy/sell stock with cooldown</span></div><div class="code-line"><span class="keyword">function</span> maxProfit(prices):</div><div class="code-line">    n = length(prices)</div><div class="code-line"> <span class="keyword">if</span> n &lt;= 1:</div><div class="code-line"> <span class="keyword">return</span> 0</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// States: hold stock, sold (cooldown), rest</span></div><div class="code-line">    hold = -prices[0]  <span class="comment">// Bought first stock</span></div><div class="code-line">    sold = 0           <span class="comment">// Just sold</span></div><div class="code-line">    rest = 0           <span class="comment">// Resting/can buy</span></div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for</span> i = 1 <span class="keyword">to</span> n - 1:</div><div class="code-line">        prevHold = hold</div><div class="code-line">        prevSold = sold</div><div class="code-line">        prevRest = rest</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Transitions</span></div><div class="code-line">        hold = max(prevHold, prevRest - prices[i])  <span class="comment">// Keep or buy</span></div><div class="code-line">        sold = prevHold + prices[i]                 <span class="comment">// Sell</span></div><div class="code-line">        rest = max(prevRest, prevSold)              <span class="comment">// Rest</span></div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> max(sold, rest)</div>
                </div>
            </div>
            <div class="card" id="dp-problem-solving-framework">
                <div class="card-header">üéì DP Problem-Solving Framework</div>
                <div class="code-block">
                    
                </div>
            </div>
            <div class="card" id="dp-pattern-recognition-map">
                <div class="card-header">üó∫Ô∏è DP Pattern Recognition Map</div>
                <div class="code-block">
                    <div class="code-line">Problem Type                    | Pattern              | State Definition</div><div class="code-line">--------------------------------|----------------------|---------------------------</div><div class="code-line">Subset selection with limit     | 0/1 Knapsack         | dp[i][w] = max value</div><div class="code-line">Unlimited item usage            | Unbounded Knapsack   | dp[amount] = min/max/count</div><div class="code-line">Two sequences comparison        | LCS                  | dp[i][j] = LCS length</div><div class="code-line">Single sequence optimization    | LIS                  | dp[i] = LIS ending at i</div><div class="code-line">Palindrome problems             | Palindrome DP        | dp[i][j] = palindrome [i,j]</div><div class="code-line">State-based decisions           | State Machine        | dp[i][state] = value</div><div class="code-line">Path counting in grid           | Grid DP              | dp[i][j] = paths to (i,j)</div><div class="code-line">Partition problems              | Partition DP         | dp[i] = can partition</div><div class="code-line">String transformation           | Edit Distance        | dp[i][j] = min operations</div>
                </div>
            </div>
            <div class="card" id="complexity-analysis">
                <div class="card-header">üí° Complexity Analysis</div>
                <div class="code-block">
                    <div class="code-line">Pattern              | Time Complexity | Space Complexity | Space Optimized</div><div class="code-line">---------------------|-----------------|------------------|------------------</div><div class="code-line">0/1 Knapsack         | O(n √ó W)        | O(n √ó W)         | O(W)</div><div class="code-line">Unbounded Knapsack   | O(n √ó W)        | O(W)             | O(W)</div><div class="code-line">LCS                  | O(m √ó n)        | O(m √ó n)         | O(min(m,n))</div><div class="code-line">LIS (DP)             | O(n¬≤)           | O(n)             | O(n)</div><div class="code-line">LIS (Binary Search)  | O(n log n)      | O(n)             | O(n)</div><div class="code-line">Palindrome DP        | O(n¬≤)           | O(n¬≤)            | O(n)</div><div class="code-line">State Machine        | O(n √ó states)   | O(n √ó states)    | O(states)</div><div class="code-line">Grid Path            | O(m √ó n)        | O(m √ó n)         | O(n)</div>
                </div>
            </div>
        </div>

        <footer>
            <p>&copy; 2025 Cheatsheets Collection. Open source and community driven.</p>
        </footer>
    </div>
</body>
</html>