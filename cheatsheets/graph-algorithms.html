<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Algorithms Cheatsheet</title>
    <link rel="stylesheet" href="../styles.css">
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="../script.js" defer></script>
</head>
<body>
    <nav class="navbar">
        <div class="nav-content">
            <a href="../index.html" class="nav-brand">
                <i class="ph ph-books"></i> Cheatsheets
            </a>
            <div class="nav-controls">
                <button id="theme-toggle" class="btn-icon" aria-label="Toggle theme">
                    <i class="ph ph-moon"></i>
                </button>
                <button id="download-btn" class="btn-icon" aria-label="Download PDF">
                    <i class="ph ph-download-simple"></i>
                </button>
                <a href="https://github.com/keyurgolani/Cheatsheets" class="btn-icon" aria-label="GitHub" target="_blank" rel="noopener noreferrer">
                    <i class="ph ph-github-logo"></i>
                </a>
            </div>
        </div>
    </nav>

    <div class="container">
        <header class="cheatsheet-header">
            <h1>üï∏Ô∏è Graph Algorithms</h1>
            <p>Essential graph traversal and shortest path algorithms with complexity analysis</p>
            <div class="search-container" style="margin-top: 1.5rem; margin-bottom: 0;">
                <span class="search-icon"><i class="ph ph-magnifying-glass"></i></span>
                <input type="text" class="search-input" id="cheatsheet-search" placeholder="Filter this cheatsheet..." aria-label="Filter cheatsheet">
            </div>
        </header>

        <div class="masonry-grid" id="cheatsheet-grid">
            
            <div class="card" id="depth-first-search-dfs">
                <div class="card-header">üå≥ Depth-First Search (DFS)</div>
                <div class="code-block">
                    <div class="code-line"><span class="comment">// Recursive approach</span></div><div class="code-line"><span class="keyword">function</span> dfs(graph, node, visited):</div><div class="code-line"> <span class="keyword">if</span> node in visited:</div><div class="code-line"> <span class="keyword">return</span></div><div class="code-line"> </div><div class="code-line">    add node to visited</div><div class="code-line">    process(node)</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for each</span> neighbor in graph[node]:</div><div class="code-line">        dfs(graph, neighbor, visited)</div>
                </div>
            </div>
            <div class="card" id="breadth-first-search-bfs">
                <div class="card-header">üìä Breadth-First Search (BFS)</div>
                <div class="code-block">
                    <div class="code-line"><span class="keyword">function</span> bfs(graph, start):</div><div class="code-line">    queue = [start]</div><div class="code-line">    visited = set([start])</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">while</span> queue not empty:</div><div class="code-line">        node = queue.dequeue()</div><div class="code-line">        process(node)</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for each</span> neighbor in graph[node]:</div><div class="code-line"> <span class="keyword">if</span> neighbor not in visited:</div><div class="code-line">                add neighbor to visited</div><div class="code-line">                queue.enqueue(neighbor)</div>
                </div>
            </div>
            <div class="card" id="dijkstras-algorithm">
                <div class="card-header">üéØ Dijkstra's Algorithm</div>
                <div class="code-block">
                    <div class="code-line"><span class="keyword">function</span> dijkstra(graph, start):</div><div class="code-line">    dist = array of size V, initialized to ‚àû</div><div class="code-line">    dist[start] = 0</div><div class="code-line">    pq = min-heap with (0, start)</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">while</span> pq not empty:</div><div class="code-line">        d, u = pq.extractMin()</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">if</span> d &gt; dist[u]:</div><div class="code-line"> <span class="keyword">continue</span></div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for each</span> (v, weight) in graph[u]:</div><div class="code-line"> <span class="keyword">if</span> dist[u] + weight &lt; dist[v]:</div><div class="code-line">                dist[v] = dist[u] + weight</div><div class="code-line">                pq.insert((dist[v], v))</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> dist</div>
                </div>
            </div>
            <div class="card" id="bellman-ford-algorithm">
                <div class="card-header">‚ö° Bellman-Ford Algorithm</div>
                <div class="code-block">
                    <div class="code-line"><span class="keyword">function</span> bellmanFord(graph, start, V, E):</div><div class="code-line">    dist = array of size V, initialized to ‚àû</div><div class="code-line">    dist[start] = 0</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Relax edges V-1 times</span></div><div class="code-line"> <span class="keyword">for</span> i = 1 <span class="keyword">to</span> V - 1:</div><div class="code-line"> <span class="keyword">for each</span> edge (u, v, weight) in E:</div><div class="code-line"> <span class="keyword">if</span> dist[u] != ‚àû and dist[u] + weight &lt; dist[v]:</div><div class="code-line">                dist[v] = dist[u] + weight</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Check for negative cycles</span></div><div class="code-line"> <span class="keyword">for each</span> edge (u, v, weight) in E:</div><div class="code-line"> <span class="keyword">if</span> dist[u] != ‚àû and dist[u] + weight &lt; dist[v]:</div><div class="code-line"> <span class="keyword">return</span> <span class="string">"Negative cycle detected"</span></div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> dist</div>
                </div>
            </div>
            <div class="card" id="floyd-warshall-algorithm">
                <div class="card-header">üåê Floyd-Warshall Algorithm</div>
                <div class="code-block">
                    <div class="code-line"><span class="keyword">function</span> floydWarshall(graph, V):</div><div class="code-line"> <span class="comment">// Initialize distance matrix</span></div><div class="code-line">    dist = V √ó V matrix, initialized to ‚àû</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for</span> i = 0 <span class="keyword">to</span> V - 1:</div><div class="code-line">        dist[i][i] = 0</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for each</span> edge (u, v, weight):</div><div class="code-line">        dist[u][v] = weight</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Dynamic programming</span></div><div class="code-line"> <span class="keyword">for</span> k = 0 <span class="keyword">to</span> V - 1:</div><div class="code-line"> <span class="keyword">for</span> i = 0 <span class="keyword">to</span> V - 1:</div><div class="code-line"> <span class="keyword">for</span> j = 0 <span class="keyword">to</span> V - 1:</div><div class="code-line"> <span class="keyword">if</span> dist[i][k] + dist[k][j] &lt; dist[i][j]:</div><div class="code-line">                    dist[i][j] = dist[i][k] + dist[k][j]</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> dist</div>
                </div>
            </div>
            <div class="card" id="kruskals-algorithm">
                <div class="card-header">üå≤ Kruskal's Algorithm</div>
                <div class="code-block">
                    <div class="code-line"><span class="keyword">function</span> kruskal(graph, V, E):</div><div class="code-line">    result = []  <span class="comment">// MST edges</span></div><div class="code-line">    uf = UnionFind(V)</div><div class="code-line"> </div><div class="code-line"> <span class="comment">// Sort edges by weight</span></div><div class="code-line">    edges = sort(E by weight)</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for each</span> edge (u, v, weight) in edges:</div><div class="code-line"> <span class="keyword">if</span> uf.find(u) != uf.find(v):</div><div class="code-line">            uf.union(u, v)</div><div class="code-line">            add edge to result</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">if</span> length(result) == V - 1:</div><div class="code-line"> <span class="keyword">break</span></div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> result</div>
                </div>
            </div>
            <div class="card" id="prims-algorithm">
                <div class="card-header">üåø Prim's Algorithm</div>
                <div class="code-block">
                    <div class="code-line"><span class="keyword">function</span> prim(graph, start, V):</div><div class="code-line">    inMST = array of size V, initialized to false</div><div class="code-line">    key = array of size V, initialized to ‚àû</div><div class="code-line">    parent = array of size V, initialized to -1</div><div class="code-line">    pq = min-heap with (0, start)</div><div class="code-line">    key[start] = 0</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">while</span> pq not empty:</div><div class="code-line">        weight, u = pq.extractMin()</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">if</span> inMST[u]:</div><div class="code-line"> <span class="keyword">continue</span></div><div class="code-line"> </div><div class="code-line">        inMST[u] = true</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for each</span> (v, w) in graph[u]:</div><div class="code-line"> <span class="keyword">if</span> not inMST[v] and w &lt; key[v]:</div><div class="code-line">                key[v] = w</div><div class="code-line">                parent[v] = u</div><div class="code-line">                pq.insert((w, v))</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> parent  <span class="comment">// MST structure</span></div>
                </div>
            </div>
            <div class="card" id="topological-sort">
                <div class="card-header">üìã Topological Sort</div>
                <div class="code-block">
                    <div class="code-line"><span class="comment">// DFS-based approach</span></div><div class="code-line"><span class="keyword">function</span> topologicalSort(graph, V):</div><div class="code-line">    visited = set()</div><div class="code-line">    stack = []</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">function</span> dfs(node):</div><div class="code-line">        add node to visited</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for each</span> neighbor in graph[node]:</div><div class="code-line"> <span class="keyword">if</span> neighbor not in visited:</div><div class="code-line">                dfs(neighbor)</div><div class="code-line"> </div><div class="code-line">        stack.push(node)</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">for each</span> vertex v in V:</div><div class="code-line"> <span class="keyword">if</span> v not in visited:</div><div class="code-line">            dfs(v)</div><div class="code-line"> </div><div class="code-line"> <span class="keyword">return</span> reverse(stack)</div>
                </div>
            </div>
            <div class="card" id="algorithm-comparison">
                <div class="card-header">üìà Algorithm Comparison</div>
                <div class="code-block">
                    <div class="code-line">Algorithm      | Time Complexity    | Space  | Negative Weights | Use Case</div><div class="code-line">---------------|-------------------|--------|------------------|---------------------------</div><div class="code-line">BFS            | O(V + E)          | O(V)   | No               | Unweighted graphs</div><div class="code-line">Dijkstra       | O((V+E) log V)    | O(V)   | No               | Non-negative weights</div><div class="code-line">Bellman-Ford   | O(V √ó E)          | O(V)   | Yes              | Negative weights, cycles</div><div class="code-line">Floyd-Warshall | O(V¬≥)             | O(V¬≤)  | Yes              | All-pairs shortest path</div>
                </div>
            </div>
            <div class="card" id="algorithm-selection-guide">
                <div class="card-header">üí° Algorithm Selection Guide</div>
                <div class="code-block">
                    
                </div>
            </div>
        </div>

        <footer>
            <p>&copy; 2025 Cheatsheets Collection. Open source and community driven.</p>
        </footer>
    </div>
</body>
</html>